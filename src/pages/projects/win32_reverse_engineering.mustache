Here I add more info on the Win32 project

- summary and bullet points of what i'll be adding next

- Encrypt / decrypt reverse engineering and a way to crack the algorithm. Try to leave it archive agnostic

- Patching of the ccbl compiler without mentioning the fact that it is CCBL (I'm afraid of microfocus)




====================================================

The "encryption" method used by Vision files is provided by the following ACME functions:

========================================================================

void __cdecl Aencrypt(char *buf, size_t size, int seed)
{
  size_t remaining; // ecx
  int x; // edx

  remaining = size;
  if ( size )
  {
    x = seed;
    do
    {
      *buf++ += x;
      x += 7;
      --remaining;
    }
    while ( remaining );
  }
}

.text:6EF24810 ; Exported entry 400.
.text:6EF24810
.text:6EF24810 ; =============== S U B R O U T I N E =======================================
.text:6EF24810
.text:6EF24810 ; Attributes: bp-based frame
.text:6EF24810
.text:6EF24810 ; void __cdecl Aencrypt(char *buf, size_t size, int seed)
.text:6EF24810                 public Aencrypt
.text:6EF24810 Aencrypt        proc near               ; CODE XREF: acme_402+64↓p
.text:6EF24810                                         ; DATA XREF: .rdata:off_6EF36588↓o
.text:6EF24810
.text:6EF24810 buf             = dword ptr  8
.text:6EF24810 size            = dword ptr  0Ch
.text:6EF24810 seed            = dword ptr  10h
.text:6EF24810
.text:6EF24810                 push    ebp
.text:6EF24811                 mov     ebp, esp
.text:6EF24813                 mov     ecx, [ebp+size]
.text:6EF24816                 test    ecx, ecx
.text:6EF24818                 jz      short loc_6EF2482D
.text:6EF2481A                 mov     edx, [ebp+seed]
.text:6EF2481D                 mov     eax, [ebp+buf]
.text:6EF24820
.text:6EF24820 loc_6EF24820:                           ; CODE XREF: Aencrypt+1B↓j
.text:6EF24820                 add     [eax], dl
.text:6EF24822                 lea     eax, [eax+1]
.text:6EF24825                 add     edx, 7
.text:6EF24828                 sub     ecx, 1
.text:6EF2482B                 jnz     short loc_6EF24820
.text:6EF2482D
.text:6EF2482D loc_6EF2482D:                           ; CODE XREF: Aencrypt+8↑j
.text:6EF2482D                 pop     ebp
.text:6EF2482E                 retn
.text:6EF2482E Aencrypt        endp
.text:6EF2482E

========================================================================

void __cdecl Adecrypt(char *buf, size_t size, int seed)
{
  size_t remaining; // ecx
  int x; // edx

  remaining = size;
  if ( size )
  {
    x = seed;
    do
    {
      *buf++ -= x;
      x += 7;
      --remaining;
    }
    while ( remaining );
  }
}

.text:6EF24830 ; Exported entry 401.
.text:6EF24830
.text:6EF24830 ; =============== S U B R O U T I N E =======================================
.text:6EF24830
.text:6EF24830 ; Attributes: bp-based frame
.text:6EF24830
.text:6EF24830 ; void __cdecl Adecrypt(char *buf, size_t size, int seed)
.text:6EF24830                 public Adecrypt
.text:6EF24830 Adecrypt        proc near               ; CODE XREF: acme_402+13A↓p
.text:6EF24830                                         ; DATA XREF: .rdata:off_6EF36588↓o
.text:6EF24830
.text:6EF24830 buf             = dword ptr  8
.text:6EF24830 size            = dword ptr  0Ch
.text:6EF24830 seed            = dword ptr  10h
.text:6EF24830
.text:6EF24830                 push    ebp
.text:6EF24831                 mov     ebp, esp
.text:6EF24833                 mov     ecx, [ebp+size]
.text:6EF24836                 test    ecx, ecx
.text:6EF24838                 jz      short loc_6EF2484D
.text:6EF2483A                 mov     edx, [ebp+seed]
.text:6EF2483D                 mov     eax, [ebp+buf]
.text:6EF24840
.text:6EF24840 loc_6EF24840:                           ; CODE XREF: Adecrypt+1B↓j
.text:6EF24840                 sub     [eax], dl
.text:6EF24842                 lea     eax, [eax+1]
.text:6EF24845                 add     edx, 7
.text:6EF24848                 sub     ecx, 1
.text:6EF2484B                 jnz     short loc_6EF24840
.text:6EF2484D
.text:6EF2484D loc_6EF2484D:                           ; CODE XREF: Adecrypt+8↑j
.text:6EF2484D                 pop     ebp
.text:6EF2484E                 retn
.text:6EF2484E Adecrypt        endp
.text:6EF2484E




====================================================


TODO: some sort of disclaimer


## Introduction
I'm using the 9.0.1 version of the Microfocus AcuCOBOL compiler, ccbl32.exe.
The actual compilation of the COBOL code is done by the ccbldll.dll and it is here that i'll focus my attention.

By issuing
```
ccbl32.exe -v
```
I'm getting:
```
License file 'C:\ccbl\ccbl32.alc' inaccessible
Micro Focus extend compiler version 9.0.1
Copyright (C) 1985-2010 Micro Focus (IP) Ltd.
```
which tells me that there is a licensing issue. Needless to say that if I try to compile a .cbl source file, the compiler stops right at the beginning showing the missing license error message.

Here's the sample COBOL program that I'll try to compile
```
       program-id. helloworld.

       environment division.
       configuration section.

       data division.
       working-storage section.

       procedure division.

           display 'Hello COBOL World!'.

           goback.

       end program helloworld.
```
Note that indentation is very important in COBOL programs. Each instruction should start at column 8, while comments should begin with a '\*' on column 7, for example.


## Setting up the process
I'm using IDA freeware as a tool to help me with the disassembly of the x86 machine code in the binary file.


## First dead end
One of the very first functions that came to my attention was `sub_60048720` and it was very promising. It seemed like that if it returns 0 the license is not valid, while if it returns true the license is valid.
These instructions appear at the very beginning of the function:
```
movsx   eax, word_600A86C0
test    eax, eax
jl      short loc_6004873D
```

which basically translates in C to something similar to, give the fact that `loc_6004873D` corresponds to the end of the function:
```
if (word_600A86C0 >= 0) {
    return word_600A86C0;
}
```
`word_600A86C0` is a flag that is initialized in the .data section of the binary to 0xFFFF, which is -1 (two's complement).
This flag is set to either 0 or 1 by the logic of the `sub_60048720` function and acts as a cache so that if the function is called multiple times, the return value is computed only once, stored in this variable and returned immediately in subsequent calls of the functions.

So my idea was to simply change the .data section of the binary and replace the 0xFFFF with a 0x0001.
After doing so, the output of the program changed to:

```
ccbl32.exe -v
Micro Focus extend compiler version 9.0.1
Copyright (C) 1985-2010 Micro Focus (IP) Ltd.
```
Which looked super promising: no more inaccessible license error.
Unfortunately, this didn't solve the problem: no compilation was performed. The program just quit without showing any error message.

## Second attempt
I then decided to look at the application exit code. It was '10' which is the same exit code returned to the operating system with no patch at all.

I therefore focused my attention to the point where the `sub_60048720` function was beeing called, and in particular to the branch that the execution takes when 0 is returned:
```
mov     eax, dword_600c4844
and     eax, 0FFFFFFFEh
mov     dword_600c4844, eax
```
which would translate to the following C code:
```
dword_600c4844 &= 0xFFFFFFFE
```
This means that the last bit of dword_600c4844 is cleared (set to 0).

I'm not sure in which other places of the program that bitmap is set. This is the only place IDA discovered. Could it be a shared memory with acme.dll? However I found a piece of code that checks if the last bit is set
```
mov     eax, dword_600c4844 		| A1 44 48 0C 60
and     eax, 1						| 83 E0 01
jnz     short loc_600490DF			| 75 0A
mov     eax, 0Ah					| B8 0A 00  00 00
jmp     loc_6004A9C4				| E9 E5 18 00 00
```

loc_6004A9C4 is the end of the function. 0x0A is 10 in decimal, which is the exit code in case of a license error. The issue is that the license_bitmask has never the last bit set to one.
The idea here is to either skip the check of the bit or set the bit.

By changing the opcode from 75 to EB, the jnz becomes an unconditional jump, like so:
```
jmp     short loc_600490DF			| EB 0A
```
...and that did the trick.

To sum up, I patched the initial value of word_600A86C0 from FF FF to 01 00 in order not to display the error message related to the license and then patched the jump instruction (75 -> EB) so that it ignored the result of the check of the bitmask.
If I only patch the jnz instruction, the program would still work, however the error message would always appear


## Other patching ideas
Another way of patching the binary would be to avoid the call to the sub_60048720 function and set the last bit of the bitmask instead.
Let's have a look at that portion of the disassembler:
```
loc_60048A32:
lea     ecx, [ebp+var_448]			| 8D 8D B8 FB FF FF
push    ecx							| 51
call    sub_60048720				| E8 E2 FC FF FF
add     esp, 4						| 83 C4 04
test    eax, eax					| 85 C0
jnz     short loc_60048A61			| 75 1C

lea     edx, [ebp+var_448]			| 8D 95 B8  FB FF FF
push    edx 						| 52
call    sub_600356A0 				| E8 4F CC FE FF
add     esp, 4						| 83 C4 04
mov     eax, dword_600c4844 		| A1 44 48 0C 60
and     eax, 0FFFFFFFEh 			| 83 E0 FE
mov     dword_600c4844, eax 		| A3 44 48 0C 60

loc_60048A61:
...
```
The idea is to insert the instructions to set the dword_600c4844 to 0x00000001 (maybe other bits have interesting meaning...) by replacing the first few instructions and then insert a NOP slide in order to preserve the original size of the binary. The opcode of the NOP instruction is 90.
One way to set dword_600c4844 to 1 could be the following:
```
xor     eax, eax				| 33 C0
inc     eax						| 40
mov     dword_600c4844, eax 	| A3 44 48 0C 60
```

And this worked too :P


## Things I learned

### Setting a register to 0
To set the return value (eax register) to zero, the compilers usually optimize it down to
```
xor     eax, eax		| 33 C0
```
In case you want to set it to 1:
```
xor     eax, eax		| 33 C0
inc     eax				| 40
```
The compiler does this instead of a `mov` instruction  beacuse the opcodes are shorter, as can be seen here:
```
mov eax, 0 				|b8 00 00 00 00
```


### Get the exit code
```
echo Exit Code is %errorlevel%
```
