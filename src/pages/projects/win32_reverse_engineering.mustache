<link href="/vendor/prism.js/prism-okaidia.css" rel="stylesheet" />
<script src="/vendor/prism.js/prism.min.js"></script>

<p>
Sometimes I like to dig deeply into some x86 Windows executables files so that I can better understand how certain piecies of software work.<br>
I decided to collect here some of the things I learned and what I think is worth noting. Here's what I'll be talking about:
</p>

<ol>
    <a href="#encryption-reverse-engineering"><li>Reverse engineering a proprietary (and very weak) encryption mechanism</li></a>
    <a href="#binary-patching"><li>Patching a binary</li></a>
    <a href="#curious-aspects"><li>Curious aspects</li></a>
</ol>

<h2 id="encryption-reverse-engineering">1. Reverse engineering a proprietary (and very weak) encryption mechanism</h2>
<p>
    As part of a personal project I am working on, I had the need to access data stored in some binary files. Unfortunately, the format of those files is proprietary
    and almost no useful information is available online: I kind of was alone in the reverse engineering of the file format.<br>
    First I disassembled, decompiled and analyzed the piece of software that is used to create and access the binary files. After a few days of headaches and guesses,
    I managed to collect enough information to correctly dump the data out of the file, which is stored in a sort of a B-Tree data structure. This must have been decided in order to
    allow indexed random access to the data records.
</p>
<p>
    In addition to simple index data storage, the file format allows for data encryption. The naive encryption method that the engineers who designed the file format put in place made me smile, at first.
    Then, I started thinking about those companies that rely on securing the data using the built-in encryption mechanism found here
</p>
<p>
    I'll now explain how the encryption works starting from the disassembly code and then I'll demonstrate how easy it is to simply do a bruteforce attack and
    decrypt the data.<br>
    The picture below is a screenshot of the IDA Freeware tool which shows the disassemby of the encryption subroutine.
</p>

<div class="text-center">
    <figure class="figure">
        <img src="/static/img/portfolio/win32_re_encrypt.png" class="figure-img img-fluid rounded" alt="IDA's proximity view of the disassemby of the encryption function">
        <figcaption class="figure-caption">IDA's proximity view of the disassemby of the encryption function</figcaption>
    </figure>
</div>

<p>
Which translates more or less to the following decompiled C:
</p>
<pre>
<code class="language-c">
/**
 * Encrypt the data stored in buf, byte by byte
 */
void encrypt(char *buf, size_t size, int seed)
{
    size_t remaining = size; // ecx register
    int x; // edx register

    //mov     ecx, [ebp+size]
    //test    ecx, ecx
    //jz      short loc_6EF2482D
    if(!remaining) {
        return;
    }

    //mov     edx, [ebp+seed]
    x = seed;

    do
    {
        //add     [eax], dl
        //lea     eax, [eax+1]
        *buf++ += x;

        //add     edx, 7
        x += 7;

        //sub     ecx, 1
        --remaining;
    }
    //jnz     short loc_6EF24820  ; The Z bit is set by the sub instruction
    while(remaining);
}
</code>
</pre>

<p>

TODO: description of the encryption algorithm. Maybe say if it is similar to the enigma machine used in WWII.

The function to decrypt the data is pretty much the same as this one, but instead of
adding 7, it removes 7 from each data byte.
</p>

<h3>Bruteforce approach to decryption of the data</h3>

<p>
    TODO
</p>

<h2 id="binary-patching">2. Patching a binary</h2>
<p>
In order to better understand how software licensing can be implemented, in the past I tried to patch an executable so that the license check is skipped.<br>
I need to say that I did so only for research purposes, that I have a genuine license of the software I studied and that I never did and never will release the patch for that software.<br>
As I did in the previous project related to file format reverse engineering, I'm using IDA freeware as a tool to help me with the disassembly of the x86 machine code in the binary file.
</p>
<h3>First dead end</h3>
<p>
One of the very first functions that came to my attention was very promising.<br>
It seemed like that it returns 0 if the license is not valid, while it returns 1 if the license is valid.<br>
These instructions appear at the very beginning of the function:
</p>

<pre>
<code>
movsx   eax, word_600A86C0
test    eax, eax
jl      short loc_6004873D
</code>
</pre>

which basically translates to C to something like the following, given the fact that <code>loc_6004873D</code> corresponds to the end of the function:
<pre>
<code class="language-c">
if (word_600A86C0 >= 0) {
    return word_600A86C0;
}
</code>
</pre>

<p>
<code>word_600A86C0</code> is a flag that is initialized in the <code>.data</code> section of the binary to 0xFFFF, which is -1 (two's complement).<br>
This flag is set to either 0 or 1 by the logic of another function (maybe the function checking for the validity of the license?) and acts as a cache so that if the function is called multiple times,
the return value is computed only once, stored in this variable and returned immediately in subsequent calls of the function.
</p>
<p>
At this point, my idea was to simply change the <code>.data</code> section of the binary and replace the 0xFFFF with a 0x0001. This way the function that sets this value would never be called and
everything would behave as if that function did execute and returned 1.<br>
I opened up my hex editor and quickly changed those two bytes from FF FF to 01 00.<br>
However, that unfortunately did not work. Only one thing changed: the message related to the invalid license was no longer printed to the screen, but everything else (including the software protection mechanism)
worked as intended. This meant that it was a dead end and that I needed to continue analyzing the assembly code.
</p>

<h3>Second attempt</h3>
<p>
I then decided to look at the application exit code returned to the operating system. It was '10' which is the same exit code returned when the unpatched binary was executed.
I therefore focused my attention to the point where the function described above was beeing called, and in particular to the branch that the execution takes when 0 is returned:
</p>
<pre>
<code>
mov     eax, dword_600c4844
and     eax, 0FFFFFFFEh
mov     dword_600c4844, eax
</code>
</pre>

<p>
which translates to the following C code:
</p>
<pre>
<code class="language-c">
dword_600c4844 &= 0xFFFFFFFE
</code>
</pre>

<p>
This means that the last bit of the dword_600c4844 bitmask is cleared (set to 0).
I then found a piece of code that checks if this last bit is set:
</p>

<pre>
<code>
mov     eax, dword_600c4844
and     eax, 1
jnz     short loc_600490DF
mov     eax, 0Ah
jmp     loc_6004A9C4
</code>
</pre>

<p>
<code>loc_6004A9C4</code> is the end of the function. 0x0A is 10 in decimal, which is the exit code in case of a license error.
The reason why the initial attempt failed is that the last bit of the bitmask never gets set to one.
The new idea here was to either skip the check of the bit or set the bit.
</p>
<p>
By changing the opcode from 75 to EB, the <code>jnz</code> becomes an unconditional jump <code>jmp</code>, like so:
</p>
<pre>
<code>
jmp     short loc_600490DF
</code>
</pre>
<p>
...and that did the trick. :)
</p>

<p>
To sum up, I patched the initial value of word_600A86C0 from FF FF to 01 00 in order not to display the error message related to the license and then patched the jump instruction (75 -> EB) so
that it ignored the result of the check of the bitmask.
If I only patched the <code>jnz</code> instruction, the patch would still work, however the error message would always appear.
</p>

<h3>Other patching ideas</h3>
<p>
Another way of patching the binary would be to avoid the call to the previously described function and directly set the last bit of the bitmask instead.
Let's have a look at that portion of the disassembly code:
</p>
<pre>
<code>
loc_60048A32:
lea     ecx, [ebp+var_448]
push    ecx
call    sub_60048720
add     esp, 4
test    eax, eax
jnz     short loc_60048A61

lea     edx, [ebp+var_448]
push    edx
call    sub_600356A0
add     esp, 4
mov     eax, dword_600c4844
and     eax, 0FFFFFFFEh
mov     dword_600c4844, eax

loc_60048A61:
...
</code>
</pre>

<p>
The idea is to insert the instructions to set the dword_600c4844 to 0x00000001 (maybe other bits have interesting meaning...) by replacing the first few instructions and then insert a NOP slide in order to preserve the original size of the binary. The opcode of the NOP instruction is 90.
One way to set dword_600c4844 to 1 could be the following:
</p>
<pre>
<code>
xor     eax, eax
inc     eax
mov     dword_600c4844, eax
</code>
</pre>

<p>
And this worked too :P
</p>

<h3>Conclusion</h3>
<p>
I'm sure that there are a lot of other ways to patch this binary in order to bypass the check, and this highlights my goal which is to show how easy it is to change the behaviour of a piece of software.
The licensing system can be extremely complex, but most of the times (I would guess) it comes down to changing the few instructions that process the output of the license check, which is just a boolean value.<br>
The only way to prevent binary patching is to <i>require</i> the execution of signed code, which is what's been done with smarphone apps. However computers where born a long time ago, when this kind of software security
wasn't the priority. For backward compatibility, execution of unsigned code is possible to this day on many platforms.
</p>


<h2 id="curious-aspects">3. Curious aspects</h2>
<h3>Setting a register to 0</h3>

<p>
To set the return value (eax register) to zero, the compilers usually optimize it like this:
</p>
<pre>
<code>
xor     eax, eax        | 33 C0
</code>
</pre>

<p>
In case you want to set it to 1:
</p>
<pre>
<code>
xor     eax, eax        | 33 C0
inc     eax             | 40
</code>
</pre>

<p>
The compiler does this instead of a <code>mov</code> instruction beacuse the opcodes are shorter, as can be seen here:
</p>
<pre>
<code>
mov eax, 0              | B8 00 00 00 00
</code>
</pre>
<p>
The hex digits next to each instruction represent the raw assembly instructions. In the first two implementation the code needs 2 or 3 bytes of memory, while the <code>mov</code> instruction requires 5 bytes.
</p>
